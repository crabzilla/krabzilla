= Krabzila Documentation
:revnumber: {project-version}
:example-caption!:
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../../main/java]

== Introduction

Krabzilla aims to help you write your domain model with very little framework overhead and smoothly deploy it on a
state of art Java 8 reactive applications platform backed by a rock solid relational database of your choice. Krabzilla
was created by rewriting some Java components from Crabzilla in Kotlin.

== The approach

Krabzilla expects you to implement your bounded context by writing these components:

[cols="2,6a,3a,1", options="header"]
|===
|Component
|Core module components
|Service module components
|Cardinality

|Aggregate
|* fun seedValueFn(): () -> Lazy<E>
* fun stateTransitionFn(): DomainEvent<E> -> E
* fun cmdValidatorFn(): EntityCommand -> List<String>
* fun cmdHandlerFn(): EntityCommandHandlerFn<E>
| * fun depInjectionFn(): (E) -> E
* fun snapshotUpgrader(): SnapshotUpgraderFn<E>
| N

|External System
|TBD
|TBD
| N

|Policy
|TBD
|TBD
| N

|Events projection
|TBD
|TBD
| 1

|===

These functions are more explicit here:

[source,kotlin]
.domain.kt
----
include::./krabzilla-core/src/main/java/crabzilla/domain.kt[tags=entities_functions,indent=0]
----

Krabzilla will observe the results from these functions and will persist these results:

* EntityUnitOfWork
* UnitOfWork
* Reactions
* Scheduled commands

(WORK IN PROGRESS)

== krabzilla-example1

This example show how to write a simplistic (and useless) aggregate root: Customer.

* An user can create a new customer
* An user can activate a existing customer
* An user can deactivate a existing customer
* An user can create and activate a new customer

[.thumb]
image::example1.png[scaledwidth=100%]

=== Events and commands
Let's start by examining these events and commands:

[source,kotlin]
.CustomerData.kt
----
include::./krabzilla-example1/krabzilla-example1-core/src/main/java/crabzilla/example1/aggregates/CustomerData.kt[ ]
----

<1> An identifier type for you aggregate
<2> The events
<3> The commands
<4> Just a command for testing purposes

=== Functions

[source,kotlin]
.CustomerFunctions.kt
----
include::./krabzilla-example1/krabzilla-example1-core/src/main/java/crabzilla/example1/aggregates/CustomerFunctions.kt[ ]
----

<1> Function to return an initial "empty" value for your Customer
<2> Function to apply state transitions on Customer instances
<3> Function to validate Customer commands
<4> Function to handle a command

So far you have just plain functions. No side effects.

=== Aggregate

[source,kotlin]
.Customer.kt
----
include::./krabzilla-example1/krabzilla-example1-core/src/main/java/crabzilla/example1/aggregates/Customer.kt[ ]
----

=== Read Model

[source,sql]
.V2__read_model.sql
----
include::./krabzilla-example1/krabzilla-example1-database/src/main/resources/db/migration/migration/V2__read_model.sql[tags=readmodel]
----

Your read model is just your database schema. Code is generated by https://www.jooq.org/[JOOQ].

== krabzilla-vertx-example1

Now your model is validated and tested. You still need to do:

1) Plug your more functions: EventsProjector
2) Wire and configure the components

After this, you will be able to run it. You will have these features:

* HTTP interface to submit commands
* Concurrent command validation and processing
* Events storing to a single and partitioned MYSQL 8 table
* Events projection to the read model database.


=== Wiring the functions

Wiring is very boilerplate so instead of the implementation, let's see the interfaces instead:

[source,kotlin]
.domain.kt
----
include::./krabzilla-core/src/main/java/crabzilla/domain.kt[tags=factory,indent=0]
----


== Attributes

.Built-in
asciidoctor-version:: {asciidoctor-version}
safe-mode-name:: {safe-mode-name}
docdir:: {docdir}
docfile:: {docfile}
imagesdir:: {imagesdir}

.Custom
project-version:: {project-version}
sourcedir:: {sourcedir}
endpoint-url:: {endpoint-url}

== Includes

.include::subdir/_b.adoc[]
====
include::subdir/_b.adoc[]
====

WARNING: Includes can be tricky!
