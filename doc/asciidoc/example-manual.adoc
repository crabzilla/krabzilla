= Krabzila Documentation
:revnumber: {project-version}
:example-caption!:
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../../main/java]

Status: *WORK IN PROGRESS*

== Goal for version 1.0.0

To help you write your domain model with very little framework overhead and smoothly deploy it on a state of art Java 8
reactive applications platform backed by a rock solid relational database of your choice.

== Approach

Before even trying to implement your domain model, you need a good foundation. http://eventstorming.com[Eventstorming]
is a very interesting domain model discovering approach. Krabzilla is inspired by it. With Krabzilla, you will have to
develop these components:

*Notice* : I still miss *a lot* of Eventstorming knowledge, all I know is from my own understanding of simply reading
the in progress book. Be careful :)

== Eventstorming

* DomainEvent
* Command
* Aggregate
* ExternalSystem
* Listener
* ProcessManager

== Modules

Krabzilla has 2 modules:

 krabzilla             → Project root
  └ krabzilla-core     → The core abstractions: Command, DomainEvent, Aggregate, Snapshot, etc
  └ krabzilla-vertx    → The application engine: runs your domain model

and your typical *example1* bounded context project will have this structure:

 example1             → Project root
  └ example1-core     → Your domain code. Services as interfaces. Almost zero dependencies.
  └ example1-database → Flyway database setup with both read and write models. Repositories implementation.
  └ example1-service  → The application: wiring, configuration and services implementations.

Load, integration and acceptance tests are against the service module.

The dependencies between the modules:

[.thumb]
image::modules.png[scaledwidth=100%]

== The approach

Krabzilla expects you to implement your bounded context by writing functions. For:

[cols="2,5a,3a", options="header"]
|===
|Component
|Core module
|Service module


|Aggregate
|* seedValueFn(): () -> Lazy<E>
* stateTransitionFn(): DomainEvent<E> -> E
* cmdValidatorFn(): EntityCommand -> List<String>
* cmdHandlerFn(): EntityCommandHandlerFn<E>
| * depInjectionFn(): (E) -> E

|External System
|
|

|Listener
|
|

|Process Manager
|
|

|Events Projector
|
|

|===

*EntityCommandHandlerFn* is a function too:

:source-highlighter: highlightjs
[source,kotlin]
.domain.kt
----
include::./krabzilla-core/src/main/java/crabzilla/domain.kt[tags=entities_functions,indent=0]
----

Krabzilla will observe the results from these functions and will persist these results:

* EntityUnitOfWork
* UnitOfWork
* Reactions
* Scheduled commands

== krabzilla-example1

This example show how to write a simplistic (and useless) aggregate root: Customer.

* An user can create a new customer
* An user can activate a existing customer
* An user can deactivate a existing customer
* An user can create and activate a new customer

[.thumb]
image::example1.png[scaledwidth=100%]

=== Events and commands
Let's start by examining these events and commands:

[source,kotlin]
.CustomerData.kt
----
include::./krabzilla-example1/krabzilla-example1-core/src/main/java/crabzilla/example1/aggregates/CustomerData.kt[ ]
----

<1> An identifier type for you aggregate
<2> The events
<3> The commands
<4> Just a command for testing purposes

=== Functions

[source,kotlin]
.CustomerFunctions.kt
----
include::./krabzilla-example1/krabzilla-example1-core/src/main/java/crabzilla/example1/aggregates/CustomerFunctions.kt[ ]
----

<1> Function to return an initial "empty" value for your Customer
<2> Function to apply state transitions on Customer instances
<3> Function to validate Customer commands
<4> Function to handle a command

So far you have just plain functions. No side effects.

=== Aggregate

[source,kotlin]
.Customer.kt
----
include::./krabzilla-example1/krabzilla-example1-core/src/main/java/crabzilla/example1/aggregates/Customer.kt[ ]
----

=== Read Model

[source,sql]
.V2__read_model.sql
----
include::./krabzilla-example1/krabzilla-example1-database/src/main/resources/db/migration/migration/V2__read_model.sql[tags=readmodel]
----

Your read model is just your database schema. Code is generated by https://www.jooq.org/[JOOQ].

== krabzilla-vertx-example1

Now your model is validated and tested. You still need to do:

1) Plug your more functions: EventsProjector
2) Wire and configure the components

After this, you will be able to run it. You will have these features:

* HTTP interface to submit commands
* Concurrent command validation and processing
* Events storing to a single and partitioned MYSQL 8 table
* Events projection to the read model database.


=== Wiring the functions

Wiring is very boilerplate so instead of the implementation, let's see the interfaces instead:

[source,kotlin]
.domain.kt
----
include::./krabzilla-core/src/main/java/crabzilla/domain.kt[tags=factory,indent=0]
----


== Attributes

.Built-in
asciidoctor-version:: {asciidoctor-version}
safe-mode-name:: {safe-mode-name}
docdir:: {docdir}
docfile:: {docfile}
imagesdir:: {imagesdir}

.Custom
project-version:: {project-version}
sourcedir:: {sourcedir}
endpoint-url:: {endpoint-url}

== Includes

.include::subdir/_b.adoc[]
====
include::subdir/_b.adoc[]
====

WARNING: Includes can be tricky!
